키-값 저장소 설계
=

키-값 저장소란 키-값 데이터 베이스라고도 불리우는 데이터베이스이다.
고유한 식별자를 키로 가지고 키-값 쌍을 생성한다.
키는 일반 텍스트여도 해시여도 좋다.
성능상의 이유로 일반적으로 짧은 것이 선호된다.
값은 무엇이 되어도 상관 없다.

분산 키-값 저장소
-
분산 키-값 저장소는 분산 해시 테이블이라고도 불리운다.
키-값 쌍을 여러 서버에 분산시키기 때문이다. (부하 분산을 통한 대규모 데이터 저장/데이터파티션/점진적 규모확장/다양성)

분산 시스템을 설계할 때에는 [CAP 정리](https://www.ibm.com/kr-ko/topics/cap-theorem)를 이해해야 한다.
CAP 정리는 1. 데이터 일관성, 2. 가용성, 3. 파티션 감내성 세 요구사항을 동시에 만족하는 분산시스템을 설계하는 것은 불가능하다는 정리이다.
정리는 셋 중 두 가지를 충족하기 위해서는 반드시 다른 하나를 희생해야 한다고 주장한다.

1. 데이터 일관성: 모든 클라이언트는 어떤 노드에 속했는지와 무관하게 언제나 같은 데이터를 보아야 한다.
2. 가용성: 모든 클라이언트는 일부 노드에 장애가 생겨도 항상 응답을 받을 수 있어야 한다.
3. 파티션 감내성: 네트워크에 통신 장애가 발생하여도 시스템은 계속 동작해야 한다는 것이다.

일반적으로 네트워크 장애는 피할 수 없는 것으로 간주되므로 분산시스템은 파티션 문제를 감내할 수 있게 설계된다.
일반적으로 CA 모델은 현실에서 보기 힘들다.

예를 들면 아래와 같다.

1. 네트워크 장애는 막기 힘드니, 일어난다고 가정한다.
2. 이 상황에서 일관성을 보장하기 위해서는, 쓰기 연산이 한 곳에서 이루어져서 데이터의 원천이 한 곳임을 보장해야 한다. 이는 가용성을 해친다.
3. 이 상황에서 가용성을 보장하기 위해서는, 일관성이 유지되지 않는다. 데이터의 원천이 여러 곳인 이상 동일성을 보장되지 않는다.

데이터 파티션
-
데이터를 파티션으로 나눌 때에는 아래의 두 가지 요소를 만족해야 한다.
그렇다, 바로 안정 해시를 이용하면 된다.

1. 데이터를 여러 서버에 고르게 분산할 수 있는가?
2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화 할 수 있는가?

데이터 파티션을 통해 규모 확장 자동화, 서버 용량에 알맞게 가상 노드를 조절하는 등의 다양성 확보가 유리하다.

데이터 다중화
-
고가용성과 안정성을 확보하기 위해서는 데이터를 N개의 서버에 비동기적으로 다중화 할 필요가 있다.

같은 센터에 속한 경우 물리적 재해의 영향을 받을 수 있기 때문에 데이터의 사본은 다른 센터의 서버에 보관하고 고속 네트워크로 연결한다.

데이터 일관성
-
정족수 합의 프로토콜을 사용하면 쓰기와 읽기 연산 모두에 일관성을 보장할 수 있다.

쓰기/읽기 연산이 성공했다는 것을 장담하려면 중재자는 적어도 W/R개의 서버로부터 연산이 성공했다는 응답을 받아야 한다.

중재자는 클라이언트와 서버 사이의 프록시 역할을 한다.
N/W/R의 값을 구하는 것은 응답지연과 데이터 일관성 사이의 타협점을 찾는 과정이다.

W + R > N인 경우, 강한 일관성이 보장된다. (모든 사본에 쓰기 연산이 저장될 때까지 읽기를 금지하는 것)

궁극적 일관성 모델의 경우에는 쓰기연산이 병렬적으로 일어나면 일관성이 깨질 수 있는데, 이는 클라이언트에서 해결해야 한다.

데이터를 다중화하면 가용성은 높아지나 일관성이 깨질 가능성이 높아진다.
버저닝과 벡터 시계는 이 문제를 해소하는 방법이다.

데이터 버저닝
-
버저닝은 데이터를 변경할 때마다 새로운 버전을 만드는 것을 의미한다.
각 버전의 데이터는 변경불가이다.

문제 상황을 예를 들어보겠다.
동시에 데이터 변경이 서로 다른 클라이언트에서 서로 다른 노드로 요청된다면 무엇을 진실로 삼아야 할까?

이 충돌을 발견하고 자동으로 해소하는 버저닝 시스템으로 벡터 시계가 있다.  (쓰기 연산에 대한 높은 가용성)

벡터 시계란 [서버, 버전]의 순서쌍을 데이터에 매단 것이다.
버전 간의 선 후행관계, 다른 버전과의 충돌 여부를 판단하는 데에 사용된다.

하지만 충돌 감지와 해소 로직이 클라이언트에 들어가므로 클라이언트 구현이 복잡해진다는 점, [서버, 버전]의 순서쌍이 빠르게 늘어나 임계치를 설정하고 오래된 순서쌍을 제거해주어야 한다는 단점이 있다.

장애 감지
-
모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 가장 손쉬운 방법이나 서버의 수가 늘어나면 비효율이 발생한다.
가십 프로토콜 같이 분산형 장애 감지 솔루션을 채택하는 것이 보다 효율적이다.

가십 프로토콜은 무작위로 선정된 다른 노드에 하트비트를 보내고, 이 박동 카운터가 일정시간 갱신되지 않으면 해당 노드를 장애상태로 간주한다.

일시적 장애 처리
-
가십 프로토콜로 장애를 감지한 시스템은 가용성을 보장하기 위한 조치를 해야 한다.
엄격한 정족수 접근법을 사용한다면 읽기와 쓰기 연산을 금지해야 할 것이다.
느슨한 정족수 접근법을 사용한다면 W, R 개의 건강한 서버를 링에서 대표로 골라 가용성을 높일 수 있다. (조절가능한 데이터 일관성)

이때, 장애 처리 대안 중 하나로 단서 후 임시위탁이라는 방법을 사용한다. 
네트워크/서버 문제로 장애상태인 요청은 잠시 다른 서버가 맡아 처리한다. 
이 사이 발생한 변경사항은 서버가 복구되었을 때 일괄반영하여 데이터 일관성을 보존한다. 
이를 위해 임시로 쓰기 연산을 처리한 서버에는 단서를 남긴다. 

영구 장애 처리
-
반-엔트로피 프로토콜은 사본을 비교하여 최신버전으로 갱신하는 과정을 통해 동기화를 한다.
사본간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서는 [머클 트리](https://www.banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl)를 사용하다.
머클트리를 사용하면 동기화해야하는 데이터는 실제로 존재하는 차이에 비례한다는 장점이 있다.

데이터 센터 장애 처리
-
데이터를 여러 센터에 다중화하는 것이 중요하다. (읽기 연산에 대한 높은 가용성)




